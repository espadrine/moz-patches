# HG changeset patch
# Parent 1cd521c380451c28bcb0d01b25330e16813ffdbd
# User Thaddee Tyl <thaddee.tyl@gmail.com>
Bug 762164 — Implement Autocompletion in the Source Editor

diff --git a/browser/devtools/scratchpad/scratchpad.js b/browser/devtools/scratchpad/scratchpad.js
--- a/browser/devtools/scratchpad/scratchpad.js
+++ b/browser/devtools/scratchpad/scratchpad.js
@@ -400,6 +400,22 @@ var Scratchpad = {
   },
 
   /**
+   * Get the sandbox currently in use (either the chrome sandbox, or the tab
+   * content sandbox).
+   *
+   * @return mixed
+   *         The sandbox currently in use.
+   */
+  getSandbox: function SP_getSandbox()
+  {
+    // Evaluate the sandbox one to get all the autocompletion we can.
+    this.evalForContext("");
+    return this.executionContext == SCRATCHPAD_CONTEXT_CONTENT ?
+           this._contentSandbox :
+           this._chromeSandbox;
+  },
+
+  /**
    * Execute the selected text (if any) or the entire editor content in the
    * current context.
    * @return mixed
@@ -1041,11 +1057,13 @@ var Scratchpad = {
 
     this.editor = new SourceEditor();
 
+    let getSandbox = this.getSandbox.bind(this);
     let config = {
       mode: SourceEditor.MODES.JAVASCRIPT,
       showLineNumbers: true,
       initialText: initialText,
       contextMenu: "scratchpad-text-popup",
+      getSandbox: getSandbox,
     };
 
     let editorPlaceholder = document.getElementById("scratchpad-editor");
diff --git a/browser/devtools/scratchpad/test/Makefile.in b/browser/devtools/scratchpad/test/Makefile.in
--- a/browser/devtools/scratchpad/test/Makefile.in
+++ b/browser/devtools/scratchpad/test/Makefile.in
@@ -33,6 +33,7 @@ MOCHITEST_BROWSER_FILES = \
 		browser_scratchpad_bug_650760_help_key.js \
 		browser_scratchpad_bug_651942_recent_files.js \
 		browser_scratchpad_bug756681_display_non_error_exceptions.js \
+		browser_scratchpad_bug_762164_autocompletion.js \
 		head.js \
 
 include $(topsrcdir)/config/rules.mk
diff --git a/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js b/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js
--- a/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js
+++ b/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js
@@ -36,22 +36,22 @@ function runTests()
 
   is(sp.editor.getCaretOffset(), 5, "caret location is correct");
 
-  sp.editor.setCaretOffset(6);
+  sp.editor.setCaretOffset(16);
 
   EventUtils.synthesizeKey("VK_TAB", {}, gScratchpadWindow);
 
-  is(sp.getText(), "     w    indow.foo;",
+  is(sp.getText(), "     window.foo;    ",
      "Tab key added 4 spaces");
 
-  is(sp.editor.getCaretOffset(), 10, "caret location is correct");
+  is(sp.editor.getCaretOffset(), 20, "caret location is correct");
 
   // Test the new insertTextAtCaret() method.
 
   sp.insertTextAtCaret("omg");
 
-  is(sp.getText(), "     w    omgindow.foo;", "insertTextAtCaret() works");
+  is(sp.getText(), "     window.foo;    omg", "insertTextAtCaret() works");
 
-  is(sp.editor.getCaretOffset(), 13, "caret location is correct after update");
+  is(sp.editor.getCaretOffset(), 23, "caret location is correct after update");
 
   gScratchpadWindow.close();
 
diff --git a/browser/devtools/scratchpad/test/browser_scratchpad_bug_762164_autocompletion.js b/browser/devtools/scratchpad/test/browser_scratchpad_bug_762164_autocompletion.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/scratchpad/test/browser_scratchpad_bug_762164_autocompletion.js
@@ -0,0 +1,48 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+function test() {
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function onTabLoad() {
+    gBrowser.selectedBrowser.removeEventListener("load", onTabLoad, true);
+
+    ok(window.Scratchpad, "Scratchpad variable exists");
+
+    Services.prefs.setIntPref("devtools.editor.tabsize", 5);
+
+    openScratchpad(runTests);
+  }, true);
+
+  content.location = "data:text/html,Scratchpad test for the Tab key, bug 660560";
+}
+
+function runTests() {
+  // 1. Test automatic insertion.
+
+  let sp = gScratchpadWindow.Scratchpad;
+
+  sp.setText("window.O");
+  // Position the cursor after the "O".
+  sp.editor.setCaretOffset(8);
+
+  EventUtils.synthesizeKey("VK_TAB", {}, gScratchpadWindow);
+
+  is(sp.getText(), "window.Object",
+     "Autocompletion of window.O → window.Object");
+
+  // 2. Test the existence of the popover.
+
+  sp.setText("window.F");
+  sp.editor.setCaretOffset(8);
+
+  EventUtils.synthesizeKey("VK_TAB", {}, gScratchpadWindow);
+
+  let popover = sp.editor._autocomplete.popover;
+  is(popover.style.display, "block",
+     "Autocompletion of window.F gives a popover");
+
+  finish();
+}
diff --git a/browser/devtools/sourceeditor/Makefile.in b/browser/devtools/sourceeditor/Makefile.in
--- a/browser/devtools/sourceeditor/Makefile.in
+++ b/browser/devtools/sourceeditor/Makefile.in
@@ -14,6 +14,7 @@ TEST_DIRS += test
 
 EXTRA_JS_MODULES = \
 	source-editor.jsm \
+	autocompletion.jsm \
 	source-editor-orion.jsm \
 	source-editor-ui.jsm \
 	$(NULL)
diff --git a/browser/devtools/sourceeditor/autocompletion.jsm b/browser/devtools/sourceeditor/autocompletion.jsm
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/autocompletion.jsm
@@ -0,0 +1,709 @@
+/* vim:set ts=2 sw=2 sts=2 et tw=80:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const Cu = Components.utils;
+Cu.import("resource:///modules/WebConsoleUtils.jsm");
+Cu.import("resource://gre/modules/reflect.jsm");
+
+var EXPORTED_SYMBOLS = ["Autocompletion"];
+
+/**
+ * Create a new popover. It gets a "div.popover" class.
+ * It starts invisible (display: none).
+ *
+ * @param object document
+ *        The DOM document in which to add a popover.
+ *
+ * @param string cssClass
+ *        The CSS class that you want it to have (optional).
+ *
+ * @return object popover
+ *         The DOM element representing the popover.
+ */
+function createPopover(document, cssClass) {
+  let popover = document.createElement("div");
+  popover.classList.add("popover");
+  if (cssClass) {
+    popover.classList.add(cssClass);
+  }
+  popover.style.position = "absolute";
+  popover.style.display = "none";
+  popover.scrollTop = 0;
+  document.body.appendChild(popover);
+  return popover;
+}
+
+/**
+ * Autocompletion object.
+ * This constructor creates the necessary DOM popup.
+ *
+ * @param object ed
+ *        The Orion editor to target.
+ *        ed._mode must be "js".
+ *        ed._view must be a TextView.
+ *        ed._model must be a TextModel.
+ *        ed._undoStack must be an UndoStack.
+ *        ed.editorElement must be the XUL iframe containing the editor.
+ *
+ * @param object options
+ *        Properties for tuning certain defaults:
+ *        - nbVisibleCompletions (defaults to 10): number of visible
+ *          completions with respect to all possible completions.
+ *        - cssClass (defaults to "autocomplete"): CSS class used to style the
+ *          autocompletion popup.
+ *        - getSandbox (defaults to null): function to get a sandbox environment
+ *          to evaluate expressions for dynamic autocompletion purposes.
+ */
+function Autocompletion(ed, options = {}) {
+  let cssClass = options.cssClass || "autocomplete";
+  this.nbVisibleCompletions = options.nbVisibleCompletions || 10;
+  this.getSandbox = options.getSandbox || null;
+  this.editor = ed;
+  this.document = ed.editorElement.contentDocument;
+  this.popover = createPopover(this.document, cssClass);
+
+  // The function we use to autocomplete.
+  this.complete = COMPLETERS[ed._mode];
+
+  // The following will fire the autocompletion system on each character!
+  this.editor.editorElement.addEventListener("keypress", function(e) {
+    this._fireStaticAnalysis = e.keyCode == 13;
+    if (!this._insertingText && e.charCode > 0) {
+      this.document.defaultView.setTimeout(this.displayCompletion.bind(this),0);
+    }
+  }.bind(this));
+  this.editor.addEventListener("Selection", function(e) {
+    this._fireStaticAnalysis = true;
+  }.bind(this));
+
+  // Those will become event listeners.
+  this._stopBound = this.stop.bind(this);
+  this._keyBindingsBound = this._keyBindings.bind(this);
+}
+
+Autocompletion.prototype = {
+
+  // The following set the way in which the autocompletion system works.
+  getSandbox: null,
+  nbVisibleCompletions: 10,
+  complete: null,
+
+  // The following are useful DOM elements.
+  editor: null,
+  document: null,
+  popover: null,
+
+  // When the autocompletion is triggered, it is "on",
+  // and the index gives us the selected candidate.
+  _on: false,
+  _cycling: false,
+  _index: 0,
+  _start: 0,
+  _end: 0,
+  _insertingText: false,
+  _completion: null,
+  _staticCandidates: null,
+  _fireStaticAnalysis: true,
+
+  // The following two properties are functions that need to be bound to this.
+  _stopBound: null,
+  _keyBindingsBound: null,
+
+  /**
+   * Show the completions that are asked for.
+   * This function assumes there exists a
+   * popover (see function createPopover()).
+   */
+  displayCompletion: function AC_displayCompletion() {
+    dump('espadrine display completion\n');
+    if (this._completion == null) {
+      // The following line may be computationally intensive.
+      this._completion = this.complete();
+    }
+    let completions = this._completion.candidates;
+
+    // Show the popover.
+    let ed = this.editor;
+    let sel = ed.getSelection();
+    // We don't complete on a selection of text.
+    // We don't show the completion popover without any completion.
+    if (sel.start != sel.end || completions.length < 1) {
+      this.hideCompletion();
+      return;
+    }
+
+    // The first child is a <select> element.
+    let html = "<select>";
+    for (let i = 0; i < completions.length; i++) {
+      // The first option gets selected by default.
+      html += "<option " + (i == this._index? "selected='true'": "") + ">" +
+        completions[i] + "</option>";
+    }
+    html += "</select>";
+    this.popover.innerHTML = html;
+    // Track clicking on options.
+    this.popover.firstChild.addEventListener("click", function() {
+      if (this._cycling) {
+        this.cycle(this.popover.firstChild.selectedIndex - this._index);
+      } else {
+        this.cycle(this.popover.firstChild.selectedIndex + 1);
+      }
+      this.editor._view.focus();
+    }.bind(this), false);
+    this.popover.firstChild.size =
+      Math.min(this.nbVisibleCompletions, completions.length);
+
+    // Positioning the popover.
+    let coord = ed._view.getLocationAtOffset(ed._view.getCaretOffset());
+    coord.y += ed._view.getLineHeight();
+    ed._view.convert(coord, "document", "page");
+    if (!this._cycling) {
+      this.popover.style.left = coord.x + "px";
+    }
+    this.popover.style.top = coord.y + "px";
+    this.popover.style.display = "block";
+
+    // Adjust the position of the popover to ensure it fits in the viewport.
+    let dwidth = this.document.documentElement.clientWidth;
+    let dheight = this.document.documentElement.clientHeight;
+    if (coord.y + this.popover.offsetHeight > dheight) {
+      this.popover.style.top = (coord.y - this.popover.offsetHeight +
+                                - ed._view.getLineHeight()) + "px";
+    }
+    if (coord.x + this.popover.offsetWidth > dwidth) {
+      this.popover.style.left = (dwidth - this.popover.offsetWidth) + "px";
+    }
+
+    // Select the correct entry.
+    this.popover.firstChild.selectedIndex = this._index;
+
+    // Preparing the editor for turning it off,
+    // and then we turn it on.
+    this.editor.addEventListener("TextChanged",
+                                 this._stopBound);
+    this.editor.addEventListener("Selection",
+                                 this._stopBound);
+    this.editor.editorElement.addEventListener("keydown",
+                                 this._keyBindingsBound, true);
+    this._on = true;
+  },
+
+  // Specific autocompletion-only keys.
+  _keyBindings: function AC_keyBindings(e) {
+    if (e.keyCode == 27) {          // ESC key.
+      this.stop();
+      try {
+        this.editor.setText("", this._start, this._end);
+      } catch(e) {
+        dump('error ' + e.stack + '\n');
+      }
+      e.stopPropagation();
+    } else if (e.keyCode == 38) {   // ↑ key.
+      if (this._on) {
+        this.cycle(-1);
+        e.stopPropagation();
+        e.preventDefault();
+      }
+    } else if (e.keyCode == 40) {   // ↓ key.
+      if (this._on) {
+        this.cycle();
+        e.stopPropagation();
+        e.preventDefault();
+      }
+    }
+  },
+
+  /**
+   * Make the completion popup invisible.
+   */
+  hideCompletion: function AC_hideCompletion() {
+    this.popover.style.display = "none";
+    this.editor.removeEventListener("TextChanged",
+                                    this._stopBound);
+    this.editor.removeEventListener("Selection",
+                                    this._stopBound);
+    this.editor.editorElement.removeEventListener("keydown",
+                                    this._keyBindingsBound, true);
+    this._completion = null;
+    this._on = false;
+    this._index = 0;
+  },
+
+  /**
+   * Cycle through autocompletion entries.
+   *
+   * @param number count
+   *        The number of completions to advance to / go back to.
+   */
+  cycle: function AC_cycle(count = 1) {
+    if (this._cycling) {
+      this._index += count;
+      if (this._index >= this._completion.candidates.length) {
+        // Go back to the start.
+        this._index = 0;
+      } else if (this._index < 0) {
+        // Go back to the end.
+        this._index = this._completion.candidates.length - 1;
+      }
+      this.popover.firstChild.selectedIndex = this._index;
+
+      // Insert the corresponding entry.
+      this.insert(this._completion.completions[this._index]);
+
+    } else {  // We are not yet cycling.
+      // Making a new spot in the undo stack allows the user
+      // to undo the autocompletion.
+      this.editor._undoStack.endCompoundChange();
+      this.editor._undoStack.startCompoundChange();
+
+      // The following line may be computationally intensive.
+      this._completion = this.complete();
+      if (count == 0) { count = 1; }
+      if (count > 0) {
+        // We can start from the beginning.
+        this._index = count - 1;
+      } else if (count < 0) {
+        // We can also start at the end.
+        this._index = this._completion.candidates.length + count;
+      }
+
+      // Only do something if we have a completion to work with.
+      if (this._completion.candidates.length > 0) {
+        // If there is a choice to make, show the choice.
+        if (this._completion.candidates.length > 1) {
+          this.displayCompletion();
+          this._cycling = true;
+        }
+
+        // Now, show the first entry.
+        // We only do that now, because the popover must appear at the position
+        // that the cursor initially had.
+        this._start = this._end = this.editor.getCaretOffset();
+        this.insert(this._completion.completions[this._index]);
+
+        // If the popup was already displayed, hide it.
+        if (this._completion.candidates.length <= 1) {
+          this.hideCompletion();
+        }
+      }
+    }
+  },
+
+  /**
+   * Insert a possible autocompletion in the editor.
+   *
+   * @param string text
+   *        The text to insert inline.
+   */
+  insert: function AC_insert(text) {
+    this._insertingText = true;
+    this.editor.setText(text, this._start, this._end);
+    this._end = this._start + text.length;
+    this._insertingText = false;
+  },
+
+  /**
+   * Make the autocompletion popover go away, remove useless data.
+   *
+   * @return boolean
+   *         Whether the stop operation was successful.
+   */
+  stop: function AC_stop() {
+    // If the autocompletion system is going through an operation,
+    // we cannot stop it.
+    if (this._insertingText) { return false; }
+    this.hideCompletion();
+    this._cycling = false;
+    return true;
+  },
+
+};
+
+
+// Map from language file extensions to functions that can autocomplete the
+// source editor, assuming that, for each function, |this| is an
+// instance of Autocompletion.
+const COMPLETERS = {
+  /**
+   * Get a list of completions we can have, based on the state of the editor.
+   * Autocompletion happens based on the following factors
+   * (with increasing relevance):
+   *
+   * Level 0 = JS keywords.
+   * Level 1 = dynamic lookup of available properties.
+   *
+   * Use candidates for UI purposes, and completions when inserting the completion
+   * in the editor.
+   *
+   * @return object completion
+   *         An object with the following fields:
+   *         - candidates: A list of the matches to a possible completion.
+   *         - completions: A list of the associated completion to a candidate.
+   */
+  js: function AC_JSCompleter() {
+    let caret = this.editor.getCaretPosition();
+    let line = this.editor._model.getLine(caret.line);
+    let root = line.substr(0, caret.col);
+
+    let candidates = [];
+    let completions = [];
+
+    // We use a primitive sorting algorithm.
+    // The candidates are simply concatenated, level after level.
+    // We assume that Level 0 < Level 1 < etc.
+
+    let source = this.editor.getText();
+    let identifier = getIdentifier(source, this.editor.getCaretOffset());
+
+    // Static analysis (Level 2).
+
+    // Only do this (possibly expensive) operation once every new line.
+    if (this._staticCandidates == null || this._fireStaticAnalysis) {
+      this._staticCandidates = getStaticScope(source, caret.line + 1, caret.col) ||
+                               this._staticCandidates;
+    }
+    let staticCandidates = {};
+    // Right now, we can only complete variables.
+    if (identifier.indexOf(".") == -1 && identifier.indexOf("[") == -1 &&
+        // Thou shalt only complete what there is to complete.
+        identifier.length != 0) {
+      for (let candidate in this._staticCandidates) {
+        // The candidate must match and have something to add!
+        if (candidate.indexOf(identifier) == 0
+            && candidate.length > identifier.length) {
+          staticCandidates[candidate] = this._staticCandidates[candidate];
+        }
+      }
+      let self = this;
+      let ourCandidates = Object.keys(staticCandidates).sort(function(a, b) {
+        // Sort them according to nearest scope.
+        return self._staticCandidates[b] - self._staticCandidates[a];
+      });
+      candidates = candidates.concat(ourCandidates);
+      completions = completions.concat(ourCandidates.map(function(candidate) {
+        return candidate.slice(identifier.length);
+      }));
+    }
+
+    // Sandbox-based candidates (Level 1).
+
+    if (this.getSandbox) {
+      let sandboxCompletion = JSPropertyProvider(this.getSandbox(), root);
+      if (sandboxCompletion) {
+        candidates = candidates.concat(sandboxCompletion.matches
+            .filter(function(candidate) {
+          // We are removing candidates from level 2.
+          return staticCandidates[candidate] === undefined;
+        }));
+        completions = completions.concat(
+          sandboxCompletion.matches.map(function(candidate) {
+            return candidate.slice(sandboxCompletion.matchProp.length);
+          })
+        );
+      }
+    }
+
+    // Keyword-based candidates (Level 0).
+
+    const keywords = [
+      "break", "case", "catch", /* "class", */ "const", "continue", "debugger",
+      "default", "delete", "do", "else", "export", "false", "finally", "for",
+      "function", "get", "if", "import", "in", "instanceof", "let", "new",
+      "null", "of", "return", "set", "super", "switch", "this", "true", "throw",
+      "try", "typeof", "undefined", "var", "void", "while", "with",
+    ];
+    // This autocompletion is not meaningful when we type a property…
+    if (identifier.indexOf(".") == -1 && identifier.indexOf("[") == -1 &&
+        // Thou shalt only complete what there is to complete.
+        identifier.length !== 0) {
+      for (let keyword of keywords) {
+        // The keyword must match and have something to add!
+        if (keyword.indexOf(identifier) == 0
+            && keyword.length > identifier.length) {
+          candidates.push(keyword);
+          completions.push(keyword.slice(identifier.length));
+        }
+      }
+    }
+
+    return {
+      candidates: candidates,
+      completions: completions,
+    };
+  },
+};
+
+
+
+
+// Below this point are helper functions.
+
+
+
+/**
+ * Get all the variables in a JS script at a certain position.
+ * This gathers variable (and argument) names by means of a static analysis
+ * which it performs on a parse tree of the code.
+ *
+ * This static scope system is inflexible. If it can't parse the code, it won't
+ * give you anything.
+ *
+ * @param string script
+ *        The JS script to parse.
+ * @param number line
+ *        The line in the script from which we want the scope.
+ * @param number column
+ *        The column in the script from which we want the scope.
+ *
+ * @param object store
+ *        (Optional) The object we return. Use to avoid allocation.
+ * @param number depth
+ *        (Optional) A starting point for indicating how deeply nested variables
+ *        are.
+ *
+ * @return object|null
+ *         A map from all variable names to a number reflecting how deeply
+ *         nested in the scope the variable was. A bigger number reflects a more
+ *         deeply nested variable.
+ *         We return null if we could not parse the code.
+ */
+function getStaticScope(script, line, column, store = {}, depth = 0) {
+  let tree;
+  try {
+    tree = Reflect.parse(script);
+  } catch (e) { return null; }
+
+  let node = tree.body;
+  let stack = [];
+  let index = 0;
+  let indices = [];
+  let deeper = null;
+  do {
+    deeper = null;
+    for (; index < node.length; index++) {
+      let subnode = node[index];
+      if (subnode.type == "VariableDeclaration") {
+        declarations(subnode.declarations, store, stack.length);
+      } else if (subnode.type == "FunctionDeclaration") {
+        store[subnode.id.name] = stack.length;
+        if (caretInBlock(subnode, line, column)) {
+          // Parameters are one level deeper than the function's name itself.
+          argumentNames(subnode.params, store, stack.length + 1);
+        }
+      }
+      deeper = nestedBody(subnode);
+      if (deeper && caretInBlock(subnode, line, column)) {
+        // We need to go deeper.
+        stack.push(node);
+        node = deeper;
+        indices.push(index + 1);
+        index = 0;
+        break;
+      } else deeper = null;
+    }
+    if (!deeper) {
+      node = stack.pop();
+      index = indices.pop();
+    }
+  } while (stack.length > 0 || (node && index < node.length) || !!deeper);
+
+  return store;
+}
+
+function nestedBody(node) {
+  if (node.body) {
+    if (node.body.body) {
+      // Function declaration has a body in a body.
+      return node.body.body;
+    } else {
+      return node.body;
+    }
+  } else if (node.consequent) {
+    return node.consequent.body;  // If statements.
+  } else if (node.alternate) {
+    return node.alternate.body;  // If/else statements.
+  } else return null;
+}
+
+function caretInBlock(node, line, column) {
+  return (
+    // The node starts before the cursor.
+    (node.loc.start.line < line ||
+     (node.loc.start.line === line &&
+      node.loc.start.column <= column)) &&
+    // The node ends after the cursor.
+    (line < node.loc.end.line ||
+     (node.loc.end.line === line &&
+      column <= node.loc.end.column)));
+}
+
+function declarations(node, store, weight) {
+  for (let i = 0; i < node.length; i++) {
+    store[node[i].id.name] = weight;
+  }
+}
+
+function argumentNames(node, store, weight) {
+  for (let i = 0; i < node.length; i++) {
+    store[node[i].name] = weight;
+  }
+}
+
+
+// States.
+// IDEN can be things like |foo[bar].baz|.
+const IDEN     = 1; // identifier
+const IDEN_SP  = 2; // special chars in identifiers (spaces, dots, brackets).
+const REGEX    = 3; // regular expression
+const COMMENT  = 4; // comment
+
+// Relevant character codes.
+// May be used as states.
+const ETHER   = 0;  // ∅
+const QUOTE   = 39; // '
+const DQUOTE  = 34; // "
+const BSLASH  = 92; // \
+const SLASH   = 47; // /
+const STAR    = 42; // *
+const LF      = 10; // \n
+const DOT     = 46; // .
+const BRACK   = 91; // [
+const CBRACK  = 93; // ]
+
+// Compiled '>=!|<+-&*%^/{}()[];,~?:\\/\'"' to a map.
+const PUNCTUATION = {62:1, 61:1, 33:1, 124:1, 60:1, 43:1, 45:1, 38:1, 42:1, 37:1, 94:1, 47:1, 123:1, 125:1, 40:1, 41:1, 91:1, 93:1, 59:1, 44:1, 126:1, 63:1, 58:1, 92:1, 39:1, 34:1};
+
+/**
+ * Behold the line parser!
+ *
+ * @param string source
+ *        Some JS code.
+ * @param number offset
+ *        The position of a caret, the line on which it is positioned we will
+ *        parse.
+ *
+ * @return object
+ *         - state: The state in which we end up.
+ *         - index: The offset of the start of the element we last parsed.
+ */
+function lineParser(source, offset = source.length) {
+  // Find beginning of line.
+  let bol = offset;
+  for (;source[bol] !== "\n" && source[bol] !== "\u2028" && source[bol] !== "\u2029"
+       && bol != -1;
+       bol--) {}
+  bol++;    // Set it to the first char of the line.
+
+  // Keep track of the beginning of the object.
+  let boo = bol;
+
+  let retain = false;
+  function setState(newState) {
+    if (!retain)  { boo = i; }
+    state = newState;
+  }
+
+  let i, c, state = ETHER;
+  for (i = bol; i < offset && source[i]; i++) {
+    c = source[i].charCodeAt(0);
+    if (state == ETHER) {
+      if (c == QUOTE || c == DQUOTE || c == SLASH)  { setState(c); }
+      // Unicode identifiers, eg. |var \u0042 = 42;|.
+      else if (c == BSLASH)  { setState(IDEN); i += 5; }
+      else if (isIdentifierChar(c)) {
+        setState(IDEN);
+      } else if (retain && c == CBRACK) {
+        setState(IDEN);
+        retain = false;
+      }
+    } else if (state == QUOTE || state == DQUOTE) {
+      if (c == BSLASH)  { i++; }
+      else if (state == c)  { setState(ETHER); }
+    } else if (state == SLASH) {
+      if (c == SLASH)  { setState(COMMENT); }
+      else if (c == STAR) {
+        // Go fast to the end of the comment.
+        setState(ETHER);
+        i += source.slice(i, offset).indexOf("*/") + 2;
+        // If we currently are in a comment, say it.
+        if (i < 2) {
+          setState(COMMENT);
+          i = offset;
+        }
+      }
+      else  { setState(REGEX); }
+    } else if (state == COMMENT) {
+      if (c == LF || c == 0x2028 || c == 0x2029)  { setState(ETHER); }
+    } else if (state == REGEX) {
+      if (c == BSLASH)  { i++; }
+      else if (c == SLASH)  { setState(ETHER); }
+    } else if (state == IDEN) {
+      if (isWhiteSpace(c)) {
+        retain = true;
+        setState(IDEN_SP);
+      } else if (c == BRACK) {
+        retain = true;
+        setState(ETHER);
+      } else if (PUNCTUATION[c]) {
+        setState(ETHER);
+      }
+    } else if (state == IDEN_SP) {
+      // This state starts with retain = true.
+      if (c == DOT) {
+        setState(IDEN);
+        retain = false;
+      } else if (c == BRACK) {
+        setState(ETHER);
+      } else if (isIdentifierChar(c)) {
+        retain = false;
+        setState(IDEN);
+      } else if (PUNCTUATION[c]) {
+        retain = false;
+        setState(ETHER);
+      }
+    }
+  }
+
+  return {
+    state: state,
+    index: boo,
+  };
+}
+
+function isWhiteSpace(c) {
+  return (c === 32) || (c === 0x0009) || (c === 0x000B) ||
+    (c === 0x000C) || (c === 0x00A0) ||
+    (c >= 0x1680 &&
+     [0x1680,0x180E,0x2000,0x2001,0x2002,0x2003,0x2004,0x2005,0x2006,0x2007,0x2008,0x2009,0x200A,0x202F,0x205F,0x3000,0xFEFF].indexOf(c) >= 0);
+}
+
+function isIdentifierChar(c) {
+  return (// Non-ascii chars are identifiers, but three codes.
+          (c > 128 && c != 0xffff && c != 0x2028 && c != 0x2029) ||
+          // Letters (uppercase, lowercase) are identifier chars.
+          (c > 0x40 && c < 0x5b) || (c > 0x60 && c < 0x7b) ||
+          // $ and _ are identifier chars.
+          c == 0x5f || c == 0x24);
+}
+
+function getIdentifier(source, offset = source.length) {
+  // Remove the completion character.
+  source = source.slice(0, offset).trim();
+  let complChar = source.slice(-1);
+
+  if (complChar === "." || complChar === "[") {
+    source = source.slice(0, -1);
+    if (offset > source.length)  { offset = source.length; }
+  }
+
+  // Locate the identifier we read.
+  let f = lineParser(source, offset);
+  if (f.state == IDEN) {
+    return source.slice(f.index, offset);
+  } else return "";
+}
+
diff --git a/browser/devtools/sourceeditor/source-editor-orion.jsm b/browser/devtools/sourceeditor/source-editor-orion.jsm
--- a/browser/devtools/sourceeditor/source-editor-orion.jsm
+++ b/browser/devtools/sourceeditor/source-editor-orion.jsm
@@ -11,6 +11,7 @@ const Ci = Components.interfaces;
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource:///modules/source-editor-ui.jsm");
+Cu.import("resource:///modules/autocompletion.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
@@ -25,6 +26,7 @@ const ORION_IFRAME = "data:text/html;cha
   "<div id='editor' style='height:100%'></div>" +
   "</body></html>";
 
+
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 /**
@@ -191,6 +193,9 @@ SourceEditor.prototype = {
   _contextMenu: null,
   _dirty: false,
 
+  _getSandbox: null,
+  _autocomplete: null,
+
   /**
    * The Source Editor user interface manager.
    * @type object
@@ -247,6 +252,8 @@ SourceEditor.prototype = {
                           SourceEditor.DEFAULTS[key];
     }
 
+    this._getSandbox = aConfig.getSandbox || null;
+
     // TODO: Bug 725677 - Remove the deprecated placeholderText option from the
     // Source Editor initialization.
     if (aConfig.placeholderText) {
@@ -363,6 +370,13 @@ SourceEditor.prototype = {
 
     this.setMode(config.mode);
 
+    // The following needs the editor to have its mode set.
+    this._autocomplete = new Autocompletion(this, {
+      nbVisibleCompletions: 10,
+      cssClass: "autocomplete",
+      getSandbox: this._getSandbox,
+    });
+
     this._undoStack = new UndoStack(this._view, config.undoLimit);
 
     this._dragAndDrop = new TextDND(this._view, this._undoStack);
@@ -460,7 +474,8 @@ SourceEditor.prototype = {
 
   /**
    * The "tab" editor action implementation. This adds support for expanded tabs
-   * to spaces, and support for the indentation of multiple lines at once.
+   * to spaces, support for the indentation of multiple lines at once,
+   * and support for autocompletion.
    * @private
    */
   _doTab: function SE__doTab()
@@ -509,6 +524,15 @@ SourceEditor.prototype = {
       return true;
     }
 
+    // Do autocompletion.
+    let previousChar = this.getText()[this.getCaretOffset() - 1];
+    if (this._autocomplete && selection.start == selection.end
+        && /^[a-zA-Z0-9.$_]$/.test(previousChar)) {
+      // We have the right to autocomplete now.
+      this._autocomplete.cycle();
+      return true;
+    }
+
     return false;
   },
 
@@ -536,6 +560,16 @@ SourceEditor.prototype = {
       indent = (new Array(this._tabSize + 1)).join(" ");
     }
 
+    // Do autocompletion.
+    let previousChar = this.getText()[this.getCaretOffset() - 1];
+    if (this._autocomplete && selection.start == selection.end
+        && /^[a-zA-Z0-9.$_]$/.test(previousChar)) {
+      // We have the right to autocomplete now.
+      this._autocomplete.cycle(-1);
+      return true;
+    }
+
+    // Do selection indentation.
     let lines = [];
     for (let line, i = firstLine; i <= lastLine; i++) {
       line = model.getLine(i, true);
@@ -2029,5 +2063,8 @@ SourceEditor.prototype = {
     this._model = null;
     this._config = null;
     this._lastFind = null;
+
+    this._getSandbox = null;
+    this._autocomplete = null;
   },
 };
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/browser/devtools/webconsole/WebConsoleUtils.jsm
--- a/browser/devtools/webconsole/WebConsoleUtils.jsm
+++ b/browser/devtools/webconsole/WebConsoleUtils.jsm
@@ -968,7 +968,9 @@ function JSPropertyProvider(aScope, aInp
     }
   }
 
+  dump('webconsoleutils: matchProp ' + matchProp + '\n');
   let matches = Object.keys(getMatchedProps(obj, {matchProp:matchProp}));
+  dump('webconsoleutils: candidates  ' + matches.length + '\n');
 
   return {
     matchProp: matchProp,
