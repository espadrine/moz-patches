# HG changeset patch
# Parent c80d0e010be310c2770e6668a89ee5cce1e97f3d
# User Thaddee Tyl <thaddee.tyl@gmail.com>
Bug 762164 — Implement Autocompletion in the Source Editor

diff --git a/browser/devtools/scratchpad/scratchpad.js b/browser/devtools/scratchpad/scratchpad.js
--- a/browser/devtools/scratchpad/scratchpad.js
+++ b/browser/devtools/scratchpad/scratchpad.js
@@ -262,7 +262,7 @@ var Scratchpad = {
         this._previousLocation != this.gBrowser.contentWindow.location.href) {
       let contentWindow = this.gBrowser.selectedBrowser.contentWindow;
       this._contentSandbox = new Cu.Sandbox(contentWindow,
-        { sandboxPrototype: contentWindow, wantXrays: false, 
+        { sandboxPrototype: contentWindow, wantXrays: false,
           sandboxName: 'scratchpad-content'});
 
       this._previousBrowserWindow = this.browserWindow;
@@ -400,6 +400,20 @@ var Scratchpad = {
   },
 
   /**
+   * Get the sandbox currently in use (either the chrome sandbox, or the tab
+   * content sandbox).
+   *
+   * @return mixed
+   *         The sandbox currently in use.
+   */
+  getSandbox: function SP_getSandbox()
+  {
+    return this.executionContext == SCRATCHPAD_CONTEXT_CONTENT ?
+           this.contentSandbox :
+           this.chromeSandbox;
+  },
+
+  /**
    * Execute the selected text (if any) or the entire editor content in the
    * current context.
    * @return mixed
@@ -1041,11 +1055,13 @@ var Scratchpad = {
 
     this.editor = new SourceEditor();
 
+    let getSandbox = this.getSandbox.bind(this);
     let config = {
       mode: SourceEditor.MODES.JAVASCRIPT,
       showLineNumbers: true,
       initialText: initialText,
       contextMenu: "scratchpad-text-popup",
+      getSandbox: getSandbox,
     };
 
     let editorPlaceholder = document.getElementById("scratchpad-editor");
diff --git a/browser/devtools/scratchpad/test/Makefile.in b/browser/devtools/scratchpad/test/Makefile.in
--- a/browser/devtools/scratchpad/test/Makefile.in
+++ b/browser/devtools/scratchpad/test/Makefile.in
@@ -33,6 +33,7 @@ MOCHITEST_BROWSER_FILES = \
 		browser_scratchpad_bug_650760_help_key.js \
 		browser_scratchpad_bug_651942_recent_files.js \
 		browser_scratchpad_bug756681_display_non_error_exceptions.js \
+		browser_scratchpad_bug_762164_autocompletion.js \
 		head.js \
 
 include $(topsrcdir)/config/rules.mk
diff --git a/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js b/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js
--- a/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js
+++ b/browser/devtools/scratchpad/test/browser_scratchpad_bug_660560_tab.js
@@ -36,22 +36,22 @@ function runTests()
 
   is(sp.editor.getCaretOffset(), 5, "caret location is correct");
 
-  sp.editor.setCaretOffset(6);
+  sp.editor.setCaretOffset(16);
 
   EventUtils.synthesizeKey("VK_TAB", {}, gScratchpadWindow);
 
-  is(sp.getText(), "     w    indow.foo;",
+  is(sp.getText(), "     window.foo;    ",
      "Tab key added 4 spaces");
 
-  is(sp.editor.getCaretOffset(), 10, "caret location is correct");
+  is(sp.editor.getCaretOffset(), 20, "caret location is correct");
 
   // Test the new insertTextAtCaret() method.
 
   sp.insertTextAtCaret("omg");
 
-  is(sp.getText(), "     w    omgindow.foo;", "insertTextAtCaret() works");
+  is(sp.getText(), "     window.foo;    omg", "insertTextAtCaret() works");
 
-  is(sp.editor.getCaretOffset(), 13, "caret location is correct after update");
+  is(sp.editor.getCaretOffset(), 23, "caret location is correct after update");
 
   gScratchpadWindow.close();
 
diff --git a/browser/devtools/scratchpad/test/browser_scratchpad_bug_762164_autocompletion.js b/browser/devtools/scratchpad/test/browser_scratchpad_bug_762164_autocompletion.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/scratchpad/test/browser_scratchpad_bug_762164_autocompletion.js
@@ -0,0 +1,48 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+function test() {
+  waitForExplicitFinish();
+
+  gBrowser.selectedTab = gBrowser.addTab();
+  gBrowser.selectedBrowser.addEventListener("load", function onTabLoad() {
+    gBrowser.selectedBrowser.removeEventListener("load", onTabLoad, true);
+
+    ok(window.Scratchpad, "Scratchpad variable exists");
+
+    Services.prefs.setIntPref("devtools.editor.tabsize", 5);
+
+    openScratchpad(runTests);
+  }, true);
+
+  content.location = "data:text/html,Scratchpad test for the Tab key, bug 660560";
+}
+
+function runTests() {
+  // 1. Test automatic insertion.
+
+  let sp = gScratchpadWindow.Scratchpad;
+
+  sp.setText("window.O");
+  // Position the cursor after the "O".
+  sp.editor.setCaretOffset(8);
+
+  EventUtils.synthesizeKey("VK_TAB", {}, gScratchpadWindow);
+
+  is(sp.getText(), "window.Object",
+     "Autocompletion of window.O → window.Object");
+
+  // 2. Test the existence of the popover.
+
+  sp.setText("window.F");
+  sp.editor.setCaretOffset(8);
+
+  EventUtils.synthesizeKey("VK_TAB", {}, gScratchpadWindow);
+
+  let popover = sp.editor._autocomplete.popover;
+  is(popover.style.display, "block",
+     "Autocompletion of window.F gives a popover");
+
+  finish();
+}
diff --git a/browser/devtools/sourceeditor/Makefile.in b/browser/devtools/sourceeditor/Makefile.in
--- a/browser/devtools/sourceeditor/Makefile.in
+++ b/browser/devtools/sourceeditor/Makefile.in
@@ -19,3 +19,6 @@ EXTRA_JS_MODULES = \
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
+
+libs::
+	$(NSINSTALL) $(srcdir)/autocompletion.jsm $(FINAL_TARGET)/modules/devtools
diff --git a/browser/devtools/sourceeditor/autocompletion.jsm b/browser/devtools/sourceeditor/autocompletion.jsm
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/autocompletion.jsm
@@ -0,0 +1,867 @@
+/* vim:set ts=2 sw=2 sts=2 et tw=80:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const Cu = Components.utils;
+Cu.import("resource:///modules/WebConsoleUtils.jsm");
+Cu.import("resource://gre/modules/reflect.jsm");
+
+var EXPORTED_SYMBOLS = ["Autocompletion"];
+
+/**
+ * Create a new popover. It gets a "div.popover" class.
+ * It starts invisible (display: none).
+ *
+ * @param object aDocument
+ *        The DOM document in which to add a popover.
+ * @param string aCssClass
+ *        The CSS class that you want it to have (optional).
+ *        Defaults to "autocomplete".
+ *
+ * @return object
+ *         The DOM element representing the popover.
+ */
+function createPopover(aDocument, aCssClass = "autocomplete") {
+  let document = aDocument;
+  let cssClass = aCssClass;
+  let popover = document.createElement("div");
+  popover.classList.add("popover");
+  if (cssClass) {
+    popover.classList.add(cssClass);
+  }
+  popover.style.position = "absolute";
+  popover.style.display = "none";
+  popover.scrollTop = 0;
+  document.body.appendChild(popover);
+  return popover;
+}
+
+const NUM_VISIBLE_COMPLETIONS = 10;
+const DELAYED_POPUP = 200;
+
+/**
+ * Autocompletion object.
+ * This constructor creates the necessary DOM popup.
+ *
+ * @param object aEd
+ *        The Source Editor instance to target.
+ * @param object aOptions
+ *        Properties for tuning certain defaults:
+ *        - numVisibleCompletions (defaults to NUM_VISIBLE_COMPLETIONS): number
+ *          of visible completions with respect to all possible completions.
+ *        - cssClass (defaults to "autocomplete"): CSS class used to style the
+ *          autocompletion popup.
+ *        - getSandbox (defaults to null): function to get a sandbox environment
+ *          to evaluate expressions for dynamic autocompletion purposes.
+ *
+ *  @see NUM_VISIBLE_COMPLETIONS
+ */
+function Autocompletion(aEd, aOptions = {}) {
+  this.numVisibleCompletions = aOptions.numVisibleCompletions ||
+      NUM_VISIBLE_COMPLETIONS;
+  this.getSandbox = aOptions.getSandbox || null;
+  if (this.getSandbox) {
+    Cu.evalInSandbox("", this.getSandbox());  // Initialize the sandbox.
+  }
+  this.editor = aEd;
+  this.document = aEd.editorElement.contentDocument;
+  this.popover = createPopover(this.document, aOptions.cssClass);
+
+  // The following will fire the autocompletion system on each character!
+  this.editor.editorElement.addEventListener("keypress",
+      this._keyPress.bind(this));
+  this.editor.addEventListener("Selection", this._selection.bind(this));
+
+  // Those will become event listeners.
+  this._stopBound = this.stop.bind(this);
+  this._keyBindingsBound = this._keyBindings.bind(this);
+}
+
+Autocompletion.prototype = {
+
+  // The following set the way in which the autocompletion system works.
+  getSandbox: null,
+  numVisibleCompletions: NUM_VISIBLE_COMPLETIONS,
+
+  // The following are useful DOM elements.
+  editor: null,
+  document: null,
+  popover: null,
+
+  // When the autocompletion is triggered, it is "on",
+  // and the index gives us the selected candidate.
+  _on: false,
+  _cycling: false,
+  _index: 0,
+  _start: 0,
+  _end: 0,
+  _insertingText: false,
+  _completion: null,
+  // Static analysis would better be cached.
+  _staticCandidates: null,
+  _fireStaticAnalysis: true,
+
+  // The following two properties are functions that need to be bound to this.
+  _stopBound: null,
+  _keyBindingsBound: null,
+
+  _delayedPopup: null,
+
+  runCompleters: function AC_runCompleters()
+  {
+    if (COMPLETERS[this.editor.getMode()]) {
+      // The following line may be computationally intensive.
+      this._completion = COMPLETERS[this.editor.getMode()].bind(this)();
+    }
+  },
+
+  /**
+   * Show the completions that are asked for.
+   * This function assumes there exists a
+   * popover (see function createPopover()).
+   */
+  displayCompletion: function AC_displayCompletion()
+  {
+    if (this._completion == null) {
+      this.runCompleters();
+    }
+    let completions = this._completion.candidates;
+
+    // Show the popover.
+    let ed = this.editor;
+    let sel = ed.getSelection();
+    // We don't complete on a selection of text.
+    // We don't show the completion popover without any completion.
+    if (sel.start != sel.end || completions.length < 1) {
+      this.hideCompletion();
+      return;
+    }
+
+    // The first child is a <select> element.
+    let html = "<select>";
+    for (let i = 0; i < completions.length; i++) {
+      // The first option gets selected by default.
+      html += "<option " + (i == this._index ? "selected='true'" : "") + ">" +
+        completions[i] + "</option>";
+    }
+    html += "</select>";
+    this.popover.innerHTML = html;
+    // Track clicking on options.
+    this.popover.firstChild.addEventListener("click",
+        this._clickOnOption.bind(this));
+    this.popover.firstChild.size =
+      Math.min(this.numVisibleCompletions, completions.length);
+
+    // Positioning the popover.
+    let coord = ed.getLocationAtOffset(ed.getCaretOffset());
+    let caret = ed.getCaretPosition();
+    coord.y += ed.getLineHeight(caret.line);
+    ed.convertCoordFromDocumentToPage(coord);
+    if (!this._cycling) {
+      this.popover.style.left = coord.x + "px";
+    }
+    this.popover.style.top = coord.y + "px";
+    this.popover.style.display = "block";
+
+    // Adjust the position of the popover to ensure it fits in the viewport.
+    let dwidth = this.document.documentElement.clientWidth;
+    let dheight = this.document.documentElement.clientHeight;
+    if (coord.y + this.popover.offsetHeight > dheight) {
+      this.popover.style.top = (coord.y - this.popover.offsetHeight
+                                - ed.getLineHeight(caret.line)) + "px";
+    }
+    if (coord.x + this.popover.offsetWidth > dwidth) {
+      this.popover.style.left = (dwidth - this.popover.offsetWidth) + "px";
+    }
+
+    // Select the correct entry.
+    this.popover.firstChild.selectedIndex = this._index;
+
+    // Preparing the editor for turning it off,
+    // and then we turn it on.
+    this.editor.addEventListener("TextChanged",
+                                 this._stopBound);
+    this.editor.addEventListener("Selection",
+                                 this._stopBound);
+    this.editor.editorElement.addEventListener("keydown",
+                                 this._keyBindingsBound, true);
+    this._on = true;
+  },
+
+  // Specific autocompletion-only keys.
+  _keyBindings: function AC__keyBindings(aEvent)
+  {
+    let e = aEvent;
+    if (e.keyCode == e.DOM_VK_ESCAPE) {          // ESC key.
+      this.stop();
+      if (this._cycling) {
+        this.editor.setText("", this._start, this._end);
+      }
+      e.stopPropagation();
+    } else if (e.keyCode == e.DOM_VK_UP) {   // ↑ key.
+      if (this._on) {
+        this.cycle(-1);
+        e.stopPropagation();
+        e.preventDefault();
+      }
+    } else if (e.keyCode == e.DOM_VK_DOWN) {   // ↓ key.
+      if (this._on) {
+        if (!this._cycling) {
+          this.cycle(2);
+        } else {
+          this.cycle();
+        }
+        e.stopPropagation();
+        e.preventDefault();
+      }
+    }
+  },
+
+  _keyPress: function AC__keyPress(aEvent)
+  {
+    let e = aEvent;
+    if (!this._insertingText) {
+      if (e.keyCode == e.DOM_VK_RETURN) {
+        this._fireStaticAnalysis = true;
+      }
+      if (e.charCode) {
+        this.document.defaultView.clearTimeout(this._delayedPopup);
+        this._delayedPopup = this.document.defaultView
+            .setTimeout(this.displayCompletion.bind(this), DELAYED_POPUP);
+      }
+    }
+  },
+
+  _selection: function AC__selection(aEvent)
+  {
+    let e = aEvent;
+    // If the distance between the old position and the new is bigger than 1,
+    // the static analysis is worth updating.
+    if ((e.oldValue.start - e.newValue.start) *
+        (e.oldValue.start - e.newValue.start) > 1) {
+      this._fireStaticAnalysis = true;
+    }
+  },
+
+  _clickOnOption:  function AC__clickOnOption()
+  {
+    if (this._cycling) {
+      this.cycle(this.popover.firstChild.selectedIndex - this._index);
+    } else {
+      this.cycle(this.popover.firstChild.selectedIndex + 1);
+    }
+    this.editor.focus();
+  },
+
+  /**
+   * Make the completion popup invisible.
+   */
+  hideCompletion: function AC_hideCompletion()
+  {
+    this.popover.style.display = "none";
+    this.editor.removeEventListener("TextChanged",
+                                    this._stopBound);
+    this.editor.removeEventListener("Selection",
+                                    this._stopBound);
+    this.editor.editorElement.removeEventListener("keydown",
+                                    this._keyBindingsBound, true);
+    this._completion = null;
+    this._on = false;
+    this._index = 0;
+  },
+
+  /**
+   * Cycle through autocompletion entries.
+   *
+   * @param number aCount
+   *        The number of completions to advance to / go back to.
+   */
+  cycle: function AC_cycle(aCount = 1)
+  {
+    let count = aCount;
+    if (this._cycling) {
+      this._index += count;
+      if (this._index >= this._completion.candidates.length) {
+        // Go back to the start.
+        this._index = 0;
+      } else if (this._index < 0) {
+        // Go back to the end.
+        this._index = this._completion.candidates.length - 1;
+      }
+      this.popover.firstChild.selectedIndex = this._index;
+
+      // Insert the corresponding entry.
+      this.insert(this._completion.completions[this._index]);
+      this.editor.endCompoundChange();
+
+    } else {  // We are not yet cycling.
+      // Making a new spot in the undo stack allows the user
+      // to undo the autocompletion.
+      this.editor.startCompoundChange();
+
+      this.runCompleters();
+      if (count == 0) { count = 1; }
+      if (count > 0) {
+        // We can start from the beginning.
+        this._index = count - 1;
+      } else if (count < 0) {
+        // We can also start at the end.
+        this._index = this._completion.candidates.length + count;
+      }
+
+      // Only do something if we have a completion to work with.
+      if (this._completion.candidates.length > 0) {
+        // If there is a choice to make, show the choice.
+        if (this._completion.candidates.length > 1) {
+          this.displayCompletion();
+          this._cycling = true;
+        }
+
+        // Now, show the first entry.
+        // We only do that now, because the popover must appear at the position
+        // that the cursor initially had.
+        this._start = this._end = this.editor.getCaretOffset();
+        this.insert(this._completion.completions[this._index]);
+
+        // If the popup was already displayed, hide it.
+        if (this._completion.candidates.length <= 1) {
+          this.hideCompletion();
+        }
+      }
+    }
+  },
+
+  /**
+   * Insert a possible autocompletion in the editor.
+   *
+   * @param string aText
+   *        The text to insert inline.
+   */
+  insert: function AC_insert(aText)
+  {
+    let text = aText;
+    this._insertingText = true;
+    this.editor.setText(text, this._start, this._end);
+    this._end = this._start + text.length;
+    this._insertingText = false;
+  },
+
+  /**
+   * Make the autocompletion popover go away, remove useless data.
+   *
+   * @return boolean
+   *         Whether the stop operation was successful.
+   */
+  stop: function AC_stop()
+  {
+    // If the autocompletion system is going through an operation,
+    // we cannot stop it.
+    if (this._insertingText) { return false; }
+    this.hideCompletion();
+    this._cycling = false;
+    return true;
+  },
+
+};
+
+
+// Map from language file extensions to functions that can autocomplete the
+// source editor, assuming that, for each function, |this| is an
+// instance of Autocompletion.
+const COMPLETERS = {
+  /**
+   * Get a list of completions we can have, based on the state of the editor.
+   * Autocompletion happens based on the following factors
+   * (with increasing relevance):
+   *
+   * Level 0 = JS keywords.
+   * Level 1 = dynamic lookup of available properties.
+   * Level 2 = static analysis of the code.
+   *
+   * Use candidates for UI purposes, and completions when inserting the completion
+   * in the editor.
+   *
+   * @return object completion
+   *         An object with the following fields:
+   *         - candidates: A list of the matches to a possible completion.
+   *         - completions: A list of the associated completion to a candidate.
+   */
+  js: function AC_JSCompleter()
+  {
+    let caret = this.editor.getCaretPosition();
+    let line = this.editor.getLine(caret.line);
+    let root = line.substr(0, caret.col);
+
+    let candidates = [];
+    let completions = [];
+
+    // We use a primitive sorting algorithm.
+    // The candidates are simply concatenated, level after level.
+    // We assume that Level 0 < Level 1 < etc.
+
+    let source = this.editor.getText();
+    let identifier = getIdentifier(source, this.editor.getCaretOffset());
+
+    // Static analysis (Level 2).
+
+    // Only do this (possibly expensive) operation once every new line.
+    if (this._staticCandidates == null || this._fireStaticAnalysis) {
+      this._staticCandidates = getStaticScope(source, caret.line + 1, caret.col)
+                               || this._staticCandidates;
+      this._fireStaticAnalysis = false;
+    }
+    let allStaticCandidates = this._staticCandidates;
+    // Right now, we can only complete variables.
+    if (identifier.indexOf(".") == -1 && identifier.indexOf("[") == -1 &&
+        // Thou shalt only complete what there is to complete.
+        identifier.length != 0 && allStaticCandidates != null) {
+      let staticCandidates = [];
+      for (let [candidate, weight] of allStaticCandidates) {
+        // The candidate must match and have something to add!
+        if (candidate.indexOf(identifier) == 0
+            && candidate.length > identifier.length) {
+          staticCandidates.push(candidate);
+        }
+      }
+      staticCandidates.sort(function(a, b) {
+        // Sort them according to nearest scope.
+        return allStaticCandidates.get(b) - allStaticCandidates.get(a);
+      });
+      candidates = candidates.concat(staticCandidates);
+      completions = completions.concat(staticCandidates.map(
+          function(candidate) {
+            return candidate.slice(identifier.length);
+          }
+      ));
+    }
+
+    // Sandbox-based candidates (Level 1).
+
+    if (this.getSandbox) {
+      let sandboxCompletion = JSPropertyProvider(this.getSandbox(), root);
+      if (sandboxCompletion) {
+        candidates = candidates.concat(sandboxCompletion.matches
+            .filter(function(candidate) {
+          // We are removing candidates from level 2.
+          if (allStaticCandidates == null)  return true;
+          return !allStaticCandidates.has(candidate);
+        }));
+        completions = completions.concat(
+          sandboxCompletion.matches.map(function(candidate) {
+            return candidate.slice(sandboxCompletion.matchProp.length);
+          })
+        );
+      }
+    }
+
+    // Keyword-based candidates (Level 0).
+
+    const keywords = [
+      "break", "case", "catch", /* "class", */ "const", "continue", "debugger",
+      "default", "delete", "do", "else", "export", "false", "finally", "for",
+      "function", "get", "if", "import", "in", "instanceof", "let", "new",
+      "null", "of", "return", "set", "super", "switch", "this", "true", "throw",
+      "try", "typeof", "undefined", "var", "void", "while", "with",
+    ];
+    // This autocompletion is not meaningful when we type a property…
+    if (identifier.indexOf(".") == -1 && identifier.indexOf("[") == -1 &&
+        // Thou shalt only complete what there is to complete.
+        identifier.length !== 0) {
+      for (let keyword of keywords) {
+        // The keyword must match and have something to add!
+        if (keyword.indexOf(identifier) == 0
+            && keyword.length > identifier.length) {
+          candidates.push(keyword);
+          completions.push(keyword.slice(identifier.length));
+        }
+      }
+    }
+
+    return {
+      candidates: candidates,
+      completions: completions,
+    };
+  },
+};
+
+
+
+
+// Below this point are helper functions.
+
+
+
+/**
+ * Get all the variables in a JS script at a certain position.
+ * This gathers variable (and argument) names by means of a static analysis
+ * which it performs on a parse tree of the code.
+ *
+ * This static scope system is inflexible. If it can't parse the code, it won't
+ * give you anything.
+ *
+ * @param string aScript
+ *        The JS script to parse.
+ * @param number aLine
+ *        The line in the script from which we want the scope.
+ * @param number aColumn
+ *        The column in the script from which we want the scope.
+ * @param object aStore
+ *        (Optional) The object we return. Use to avoid allocation.
+ * @param number aDepth
+ *        (Optional) A starting point for indicating how deeply nested variables
+ *        are.
+ *
+ * @return Map|null
+ *         A map from all variable names to a number reflecting how deeply
+ *         nested in the scope the variable was. A bigger number reflects a more
+ *         deeply nested variable.
+ *         We return null if we could not parse the code.
+ */
+function getStaticScope(aScript, aLine, aColumn, aStore = new Map(), aDepth = 0) {
+  let script = aScript;
+  let line = aLine;
+  let column = aColumn;
+  let store = aStore;
+  let depth = aDepth;
+  let tree;
+  try {
+    tree = Reflect.parse(script);
+  } catch (e) { return null; }
+
+  let node = tree.body;
+  let stack = [];
+  let index = 0;
+  let indices = [];
+  let deeper = null;
+  do {
+    deeper = null;
+    for (; index < node.length; index++) {
+      let subnode = node[index];
+      while (["ReturnStatement", "VariableDeclarator", "ExpressionStatement",
+              "AssignmentExpression", "Property"].indexOf(subnode.type) >= 0) {
+        if (subnode.type == "ReturnStatement") {
+          subnode = subnode.argument;
+        }
+        if (subnode.type == "VariableDeclarator") {
+          // Variable names go one level too deep.
+          store.set(subnode.id.name, stack.length - 1);
+          if (!!subnode.init)  { subnode = subnode.init; }
+          else break;
+        }
+        if (subnode.type == "ExpressionStatement") {
+          subnode = subnode.expression;  // Parenthesized expression.
+        }
+        if (subnode.type == "AssignmentExpression") {
+          subnode = subnode.right;       // f.g = function(){…};
+        }
+        if (subnode.type == "Property") {
+          subnode = subnode.value;       // {f: function(){…}};
+        }
+      }
+      if (subnode.type == "FunctionDeclaration" ||
+          subnode.type == "FunctionExpression" ||
+          // Expressions, eg, (function(){…}());
+          (subnode.callee && subnode.callee.type == "FunctionExpression")) {
+        if (subnode.callee)  { subnode = subnode.callee; }
+        if (subnode.id)  { store.set(subnode.id.name, stack.length); }
+        if (caretInBlock(subnode, line, column)) {
+          // Parameters are one level deeper than the function's name itself.
+          argumentNames(subnode.params, store, stack.length + 1);
+        }
+      }
+      deeper = nestedNodes(subnode, line, column);
+      if (!!deeper) {
+        // We need to go deeper.
+        stack.push(node);
+        node = deeper;
+        indices.push(index + 1);
+        index = 0;
+        break;
+      } else deeper = null;
+    }
+    if (!deeper) {
+      node = stack.pop();
+      index = indices.pop();
+    }
+  } while (stack.length > 0 || (node && index < node.length) || !!deeper);
+
+  return store;
+}
+
+/**
+ * Find a parse node to iterate over.
+ * @param mixed aNode
+ *        JS parse tree node.
+ * @param number aLine
+ *        Line on which the caret is.
+ * @param number aColumn
+ *        Column on which the caret is.
+ * @return array
+ *         The node's array. Can also return null if it gets unhappy.
+ */
+function nestedNodes(aNode, aLine, aColumn) {
+  let node = aNode;
+  let line = aLine;
+  let column = aColumn;
+  let body = null;
+  let newScope = true;  // Whether we enter a new scope.
+  if (node.body) {
+    if (node.body.body) {
+      // Function declaration has a body in a body.
+      body = node.body.body;
+    } else {
+      body = node.body;
+    }
+  } else if (node.consequent) {
+    body = node.consequent.body;  // If statements.
+  } else if (node.alternate) {
+    body = node.alternate.body;   // If/else statements.
+  } else if (node.block) {
+    body = node.block.body;       // Try statements.
+  } else if (node.handlers) {     // Try/catch.
+    body = node.handlers.body.body;
+  } else if (node.finalizer) {
+    body = node.finalizer.body;   // Try/catch/finally.
+  } else if (node.declarations) {
+    body = node.declarations;     // Variable declarations.
+    newScope = false;
+  } else if (node.arguments) {
+    body = node.arguments;   // Function calls, eg, f(function(){…});
+  } else if (node.properties) {
+    body = node.properties;  // Objects, eg, ({f: function(){…}});
+  } else if (node.elements) {
+    body = node.elements;    // Array, eg, [function(){…}]
+  }
+  if (!body ||
+      // No need to parse a scope in which the caret is not.
+      (newScope && !caretInBlock(node, line, column))) {
+    return null;
+  }
+  return body;
+}
+
+/**
+ * @param mixed aNode
+ *        The parse tree node in which the caret might be.
+ * @param number aLine
+ *        The line where the caret is (starts with 1).
+ * @param number aColumn
+ *        The column where the caret is (starts with 0).
+ * @return boolean
+ *         Whether the caret is in the piece of code represented by the node.
+ */
+function caretInBlock(aNode, aLine, aColumn) {
+  let node = aNode;
+  let line = aLine;
+  let column = aColumn;
+  return (
+    // The node starts before the cursor.
+    (node.loc.start.line < line ||
+     (node.loc.start.line === line &&
+      node.loc.start.column <= column)) &&
+    // The node ends after the cursor.
+    (line < node.loc.end.line ||
+     (node.loc.end.line === line &&
+      column <= node.loc.end.column)));
+}
+
+/**
+ * Get the argument names of a function.
+ * @param array aNode
+ *        The "params" property of a FunctionExpression.
+ * @param Map aStore
+ *        Where to store the information that an identifier exists and has the
+ *        given weight.
+ * @param number aWeight
+ *        A measure of how deeply nested the node is. The deeper, the bigger.
+ */
+function argumentNames(aNode, aStore, aWeight) {
+  let node = aNode;
+  let store = aStore;
+  let weight = aWeight;
+  for (let i = 0; i < node.length; i++) {
+    store.set(node[i].name, weight);
+  }
+}
+
+
+// States.
+const STATES = {
+  // IDEN can be things like `foo[bar /* quux */].baz`.
+  IDEN     : 1, // identifier
+  IDEN_SP  : 2, // special chars in identifiers (spaces, dots, brackets).
+  REGEX    : 3, // regular expression
+  COMMENT  : 4, // comment
+
+  // Relevant character codes.
+  // May be used as states.
+  ETHER   : 0,  // ∅
+  QUOTE   : 39, // '
+  DQUOTE  : 34, // "
+  BSLASH  : 92, // \
+  SLASH   : 47, // /
+  STAR    : 42, // *
+  LF      : 10, // \n
+  DOT     : 46, // .
+  BRACK   : 91, // [
+  CBRACK  : 93, // ]
+};
+
+// Compiled '>=!|<+-&*%^/{}()[];,~?:\\/\'"' to a map.
+const PUNCTUATION = {62:1, 61:1, 33:1, 124:1, 60:1, 43:1, 45:1, 38:1, 42:1, 37:1, 94:1, 47:1, 123:1, 125:1, 40:1, 41:1, 91:1, 93:1, 59:1, 44:1, 126:1, 63:1, 58:1, 92:1, 39:1, 34:1};
+
+/**
+ * Behold the line parser!
+ *
+ * @param string aSource
+ *        Some JS code.
+ * @param number aOffset
+ *        The position of a caret, the line on which it is positioned we will
+ *        parse.
+ *
+ * @return object
+ *         - state: The state in which we end up.
+ *         - index: The offset of the start of the element we last parsed.
+ */
+function lineParser(aSource, aOffset = source.length) {
+  let source = aSource;
+  let offset = aOffset;
+  // Find beginning of line.
+  let bol = offset - 1;  // We may be *on* a newline, we want the previous line.
+  for (;source[bol] !== "\n" && source[bol] !== "\u2028" && source[bol] !== "\u2029"
+       && bol != -1;
+       bol--) {}
+  bol++;    // Set it to the first char of the line.
+
+  // Keep track of the beginning of the object.
+  let boo = bol;
+
+  let retain = false;
+  function setState(newState) {
+    if (!retain)  { boo = i; }
+    state = newState;
+  }
+
+  let i, c, state = STATES.ETHER;
+  for (i = bol; i < offset && source[i]; i++) {
+    c = source[i].charCodeAt(0);
+    if (state == STATES.ETHER) {
+      if (c == STATES.QUOTE || c == STATES.DQUOTE || c == STATES.SLASH)  {
+        setState(c);
+      }
+      // Unicode identifiers, eg. |var \u0042 = 42;|.
+      else if (c == STATES.BSLASH)  { setState(STATES.IDEN); i += 5; }
+      else if (isIdentifierChar(c)) {
+        setState(STATES.IDEN);
+      } else if (retain && c == STATES.CBRACK) {
+        setState(STATES.IDEN);
+        retain = false;
+      }
+    } else if (state == STATES.QUOTE || state == STATES.DQUOTE) {
+      if (c == STATES.BSLASH)  { i++; }
+      else if (state == c)  { setState(STATES.ETHER); }
+    } else if (state == STATES.SLASH) {
+      if (c == STATES.SLASH)  { setState(STATES.COMMENT); }
+      else if (c == STATES.STAR) {
+        // Go fast to the end of the comment.
+        setState(STATES.ETHER);
+        i += source.slice(i, offset).indexOf("*/") + 2;
+        // If we currently are in a comment, say it.
+        if (i < 2) {
+          setState(STATES.COMMENT);
+          i = offset;
+        }
+      }
+      else  { setState(STATES.REGEX); }
+    } else if (state == STATES.COMMENT) {
+      if (c == LF || c == 0x2028 || c == 0x2029)  { setState(STATES.ETHER); }
+    } else if (state == STATES.REGEX) {
+      if (c == STATES.BSLASH)  { i++; }
+      else if (c == STATES.SLASH)  { setState(STATES.ETHER); }
+    } else if (state == STATES.IDEN) {
+      if (isWhiteSpace(c)) {
+        retain = true;
+        setState(STATES.IDEN_SP);
+      } else if (c == STATES.BRACK) {
+        retain = true;
+        setState(STATES.ETHER);
+      } else if (PUNCTUATION[c]) {
+        setState(STATES.ETHER);
+      }
+    } else if (state == STATES.IDEN_SP) {
+      // This state starts with retain = true.
+      if (c == STATES.DOT) {
+        setState(STATES.IDEN);
+        retain = false;
+      } else if (c == STATES.BRACK) {
+        setState(STATES.ETHER);
+      } else if (isIdentifierChar(c)) {
+        retain = false;
+        setState(STATES.IDEN);
+      } else if (PUNCTUATION[c]) {
+        retain = false;
+        setState(STATES.ETHER);
+      }
+    }
+  }
+
+  return {
+    state: state,
+    index: boo,
+  };
+}
+
+/**
+ * Check whether the character code point is a (JS) whitespace character.
+ * @param number aCharacter
+ *        Code point for the character to check.
+ * @return boolean
+ *         true if the character is whitespace.
+ */
+function isWhiteSpace(aCharacter) {
+  let c = aCharacter;
+  return (c === 32) || (c === 0x0009) || (c === 0x000B) ||
+    (c === 0x000C) || (c === 0x00A0) ||
+    (c >= 0x1680 &&
+     [0x1680,0x180E,0x2000,0x2001,0x2002,0x2003,0x2004,0x2005,0x2006,0x2007,0x2008,0x2009,0x200A,0x202F,0x205F,0x3000,0xFEFF].indexOf(c) >= 0);
+}
+
+/**
+ * Check whether the character code point is a (JS) start identifier character.
+ * @param number aCharacter
+ *        Code point for the character to check.
+ * @return boolean
+ *         true if the character is an identifier.
+ */
+function isIdentifierChar(aCharacter) {
+  let c = aCharacter;
+  return (// Non-ascii chars are identifiers, but three codes.
+          (c > 128 && c != 0xffff && c != 0x2028 && c != 0x2029) ||
+          // Letters (uppercase, lowercase) are identifier chars.
+          (c > 0x40 && c < 0x5b) || (c > 0x60 && c < 0x7b) ||
+          // $ and _ are identifier chars.
+          c == 0x5f || c == 0x24);
+}
+
+/**
+ * Fetch a long identifier before the caret in a JS source file.
+ * @param string aSource
+ *        JS source code (may not be 100% valid JS on the current line).
+ * @param number aOffset
+ *        Position of the caret. Defaults to the end of the string.
+ * @return string
+ *         Identifier. Can be of the form `foo[bar].baz[`.
+ */
+function getIdentifier(aSource, aOffset = source.length) {
+  let source = aSource;
+  let offset = aOffset;
+  // Locate the identifier we read.
+  let f = lineParser(source, offset);
+  if (f.state == STATES.IDEN) {
+    return source.slice(f.index, offset);
+  } else return "";
+}
+
diff --git a/browser/devtools/sourceeditor/source-editor-orion.jsm b/browser/devtools/sourceeditor/source-editor-orion.jsm
--- a/browser/devtools/sourceeditor/source-editor-orion.jsm
+++ b/browser/devtools/sourceeditor/source-editor-orion.jsm
@@ -11,6 +11,7 @@ const Ci = Components.interfaces;
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource:///modules/source-editor-ui.jsm");
+Cu.import("resource:///modules/devtools/autocompletion.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
@@ -25,6 +26,7 @@ const ORION_IFRAME = "data:text/html;cha
   "<div id='editor' style='height:100%'></div>" +
   "</body></html>";
 
+
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 
 /**
@@ -191,6 +193,9 @@ SourceEditor.prototype = {
   _contextMenu: null,
   _dirty: false,
 
+  _getSandbox: null,
+  _autocomplete: null,
+
   /**
    * The Source Editor user interface manager.
    * @type object
@@ -247,6 +252,8 @@ SourceEditor.prototype = {
                           SourceEditor.DEFAULTS[key];
     }
 
+    this._getSandbox = aConfig.getSandbox;
+
     // TODO: Bug 725677 - Remove the deprecated placeholderText option from the
     // Source Editor initialization.
     if (aConfig.placeholderText) {
@@ -363,6 +370,11 @@ SourceEditor.prototype = {
 
     this.setMode(config.mode);
 
+    // The following needs the editor to have its mode set.
+    this._autocomplete = new Autocompletion(this, {
+      getSandbox: this._getSandbox,
+    });
+
     this._undoStack = new UndoStack(this._view, config.undoLimit);
 
     this._dragAndDrop = new TextDND(this._view, this._undoStack);
@@ -459,8 +471,28 @@ SourceEditor.prototype = {
   },
 
   /**
+   * Check whether we should trigger autocompletion.
+   *
+   * @private
+   * @param object aSelection
+   *        Contains the fields {start, end}. Span of the selected text in the
+   *        editor.
+   * @param string aPreviousChar
+   *        Last character inputted.
+   * @return boolean
+   *         True if we should allow autocompletion, otherwise false.
+   */
+  _isAutocompletionAllowed: function SE__isAutocompletionAllowed(aSelection,
+                                                                 aPreviousChar)
+  {
+    return this._autocomplete && aSelection.start == aSelection.end
+        && /^[a-zA-Z0-9.$_]$/.test(aPreviousChar);
+  },
+
+  /**
    * The "tab" editor action implementation. This adds support for expanded tabs
-   * to spaces, and support for the indentation of multiple lines at once.
+   * to spaces, support for the indentation of multiple lines at once,
+   * and support for autocompletion.
    * @private
    */
   _doTab: function SE__doTab()
@@ -509,6 +541,15 @@ SourceEditor.prototype = {
       return true;
     }
 
+    // Do autocompletion.
+    let previousChar = this.getText(this.getCaretOffset() - 1,
+        this.getCaretOffset());
+    if (this._isAutocompletionAllowed(selection, previousChar)) {
+      // We have the right to autocomplete now.
+      this._autocomplete.cycle();
+      return true;
+    }
+
     return false;
   },
 
@@ -536,6 +577,16 @@ SourceEditor.prototype = {
       indent = (new Array(this._tabSize + 1)).join(" ");
     }
 
+    // Do autocompletion.
+    let previousChar = this.getText(this.getCaretOffset() - 1,
+        this.getCaretOffset());
+    if (this._isAutocompletionAllowed(selection, previousChar)) {
+      // We have the right to autocomplete now.
+      this._autocomplete.cycle(-1);
+      return true;
+    }
+
+    // Do selection indentation.
     let lines = [];
     for (let line, i = firstLine; i <= lastLine; i++) {
       line = model.getLine(i, true);
@@ -1798,6 +1849,66 @@ SourceEditor.prototype = {
   },
 
   /**
+   * Returns the {x, y} pixel location of the top-left corner of the character
+   * bounding box at the specified offset in the document.  The pixel location
+   * is relative to the document.
+   *
+   * @param number offset
+   *        The character offset
+   * @returns object
+   *          The {x, y} pixel location of the given offset.
+   */
+  getLocationAtOffset: function SE_getLocationAtOffset(aOffset)
+  {
+    return this._view.getLocationAtOffset(aOffset);
+  },
+
+  /**
+   * Returns the line height for a given line index.  Returns the default line
+   * height if the line index is not specified.
+   *
+   * @param number lineIndex
+   *        The line index.
+   * @returns number
+   *          The height of the line in pixels.
+   */
+  getLineHeight: function SE_getLineHeight(aLineIndex)
+  {
+    return this._view.getLineHeight(aLineIndex);
+  },
+
+  /**
+   * Converts the given rectangle from coordinates relative to the document (the
+   * origin being hte top-left corner of the first line) to coordinates
+   * relative to the html page.
+   *
+   * @param object aCoord
+   *        An object with properties x and y.
+   */
+  convertCoordFromDocumentToPage: function SE_convertCoordFromDocumentToPage(aCoord)
+  {
+    this._view.convert(aCoord, "document", "page");
+  },
+
+  /**
+   * Returns the text of the line at the given index.
+   *
+   * The valid indices are 0 to line count exclusive.  Returns null
+   * if the index is out of range.
+   *
+   * @param number aLineIndex
+   *        The zero based index of the line.
+   * @param boolean aIncludeDelimiter
+   *        Whether or not to include the line delimiter.
+   * @returns String
+   *        The line text or null if out of range.
+   */
+  getLine: function SE_getLine(aLineIndex, aIncludeDelimiter)
+  {
+    return this._model.getLine(aLineIndex, aIncludeDelimiter);
+  },
+
+  /**
    * Setter for the read-only state of the editor.
    * @param boolean aValue
    *        Tells if you want the editor to read-only or not.
@@ -2029,5 +2140,8 @@ SourceEditor.prototype = {
     this._model = null;
     this._config = null;
     this._lastFind = null;
+
+    this._getSandbox = null;
+    this._autocomplete = null;
   },
 };
diff --git a/browser/devtools/sourceeditor/test/Makefile.in b/browser/devtools/sourceeditor/test/Makefile.in
--- a/browser/devtools/sourceeditor/test/Makefile.in
+++ b/browser/devtools/sourceeditor/test/Makefile.in
@@ -30,6 +30,7 @@ MOCHITEST_BROWSER_FILES = \
 		browser_bug725430_comment_uncomment.js \
 		browser_bug731721_debugger_stepping.js \
 		browser_bug729960_block_bracket_jump.js \
+		browser_sourceeditor_autocompletion.js \
 		head.js \
 
 include $(topsrcdir)/config/rules.mk
diff --git a/browser/devtools/sourceeditor/test/browser_sourceeditor_autocompletion.js b/browser/devtools/sourceeditor/test/browser_sourceeditor_autocompletion.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/sourceeditor/test/browser_sourceeditor_autocompletion.js
@@ -0,0 +1,80 @@
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+let testWin;
+let testDoc;
+let editor;
+
+let temp = {};
+Cu.import("resource:///modules/source-editor.jsm", temp);
+let SourceEditor = temp.SourceEditor;
+
+function test()
+{
+  waitForExplicitFinish();
+
+  const windowUrl = "data:text/xml,<?xml version='1.0'?>" +
+    "<window xmlns='http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul'" +
+    " title='test for bug 660784' width='600' height='500'><hbox flex='1'/></window>";
+  const windowFeatures = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";
+
+  testWin = Services.ww.openWindow(null, windowUrl, "_blank", windowFeatures, null);
+  testWin.addEventListener("load", function onWindowLoad() {
+    testWin.removeEventListener("load", onWindowLoad, false);
+    waitForFocus(initEditor, testWin);
+  }, false);
+}
+
+function initEditor()
+{
+  testDoc = testWin.document;
+  let hbox = testDoc.querySelector("hbox");
+  editor = new SourceEditor();
+  editor.init(hbox, {}, editorLoaded);
+}
+
+function editorLoaded()
+{
+  // JS autocompletion.
+  editor.setMode(SourceEditor.MODES.JAVASCRIPT);
+  editor.focus();
+
+  let before = "let window = {};\nwin";
+  let after = "";
+  editor.setText(before);
+  editor.setCaretOffset(before.length);
+  EventUtils.synthesizeKey("VK_TAB", {}, testWin);
+  is(editor.getText(), before + "dow", "Static JS autocompletion.");
+
+  before = "let window = {}, winnipeg = 'Manitoba';\nwin";
+  editor.setText(before);
+  editor.setCaretOffset(before.length);
+  EventUtils.synthesizeKey("VK_TAB", {}, testWin);
+  EventUtils.synthesizeKey("VK_TAB", {}, testWin);
+  is(editor.getText(), before + "nipeg", "Autocompletion: cycling twice.");
+
+  EventUtils.synthesizeKey("VK_TAB", {shiftKey: true}, testWin);
+  EventUtils.synthesizeKey("VK_TAB", {shiftKey: true}, testWin);
+  is(editor.getText(), before + "nipeg", "Autocompletion: cycling backwards.");
+
+  before = "let foo = {foo: [function(foobar){\nfoo";
+  after = "\n}]};";
+  editor.setText(before + after);
+  editor.setCaretOffset(before.length);
+  EventUtils.synthesizeKey("VK_TAB", {}, testWin);
+  is(editor.getText(), before + "bar" + after,
+     "Deep static JS autocompletion.");
+
+  testEnd();
+}
+
+function testEnd()
+{
+  editor.destroy();
+  testWin.close();
+  testWin = testDoc = editor = null;
+  waitForFocus(finish, window);
+}
diff --git a/browser/devtools/sourceeditor/test/browser_sourceeditor_initialization.js b/browser/devtools/sourceeditor/test/browser_sourceeditor_initialization.js
--- a/browser/devtools/sourceeditor/test/browser_sourceeditor_initialization.js
+++ b/browser/devtools/sourceeditor/test/browser_sourceeditor_initialization.js
@@ -168,13 +168,6 @@ function editorLoaded()
 
   is(editor.getCaretOffset(), 8, "caret moved to the left");
 
-  EventUtils.synthesizeKey(".", {}, testWin);
-  EventUtils.synthesizeKey("VK_TAB", {}, testWin);
-
-  is(editor.getText(), "code-ed..     aitor", "Tab works");
-
-  is(editor.getCaretOffset(), 14, "caret location is correct");
-
   // Test the Tab key.
 
   editor.setText("a\n  b\n c");
diff --git a/browser/devtools/webconsole/WebConsoleUtils.jsm b/browser/devtools/webconsole/WebConsoleUtils.jsm
--- a/browser/devtools/webconsole/WebConsoleUtils.jsm
+++ b/browser/devtools/webconsole/WebConsoleUtils.jsm
@@ -992,10 +992,10 @@ function JSPropertyProvider(aScope, aInp
  * @return object
  *         Object whose keys are all accessible properties on the object.
  */
-function getMatchedProps(aObj, aOptions = {matchProp: ""})
+function getMatchedProps(aObj, aOptions)
 {
   // Argument defaults.
-  aOptions.matchProp = aOptions.matchProp || "";
+  aOptions = aOptions || {matchProp: ""};
 
   if (aObj == null) { return {}; }
   try {
